{"ast":null,"code":"var minipdf = function () {\n  'use strict';\n\n  var Name = function (name) {\n    this.name = name;\n  };\n\n  function isName(obj) {\n    return obj instanceof Name;\n  }\n\n  var Dict = function (map) {\n    this.map = map;\n  };\n\n  function isDict(obj) {\n    return obj instanceof Dict;\n  }\n\n  var Stream = function (map, content) {\n    this.map = map;\n    this.content = content;\n    this.dict = new Dict(map);\n  }; // pdf.js compatibility\n\n\n  Stream.prototype.getBytes = function () {\n    return this.content;\n  };\n\n  function newStream(map, content) {\n    assert(content instanceof Uint8Array, 'stream content must be an Uint8Array');\n    return new Stream(map, content);\n  }\n\n  function isStream(obj) {\n    return obj instanceof Stream;\n  }\n\n  var Ref = function (num, gen) {\n    this.num = num;\n    this.gen = gen;\n  };\n\n  function isRef(obj) {\n    return obj instanceof Ref;\n  }\n\n  function isBool(obj) {\n    return typeof obj == 'boolean';\n  }\n\n  function isNull(obj) {\n    return obj === null;\n  }\n\n  function isString(obj) {\n    return typeof obj == 'string';\n  }\n\n  function isNum(obj) {\n    return typeof obj == 'number';\n  }\n\n  function isArray(obj) {\n    return obj instanceof Array;\n  }\n\n  function assert(x, msg) {\n    if (x) {\n      return;\n    }\n\n    if (!msg) {\n      msg = 'Assertion failed';\n    }\n\n    throw new Error(msg);\n  }\n\n  function str2buf(s) {\n    var uint = new Uint8Array(s.length);\n\n    for (var i = 0, slen = s.length; i < slen; i++) {\n      uint[i] = s.charCodeAt(i);\n    }\n\n    return uint;\n  }\n\n  function png_filter(content, columns) {\n    var cols = columns + 1;\n    var rows = content.length / cols;\n    assert(rows % 1 === 0, 'Invalid column value ' + cols + ' for image width ' + content.length);\n    var res = new Uint8Array(columns * rows);\n\n    for (var y = 0; y < rows; y++) {\n      var x;\n      var filter = content[y * cols];\n\n      if (filter === 0) {\n        for (x = 0; x < columns; x++) {\n          res[y * columns + x] = content[y * cols + 1 + x];\n        }\n      } else if (filter === 2) {\n        for (x = 0; x < columns; x++) {\n          var prev = y === 0 ? 0 : res[(y - 1) * columns + x];\n          res[y * columns + x] = prev + content[y * cols + 1 + x] & 0xff;\n        }\n      } else {\n        throw new Error('Unsupported PNG filter ' + filter);\n      }\n    }\n\n    return res;\n  }\n\n  function _merge_xrefs(xref_table, prev) {\n    var len = Math.max(xref_table.length, prev.length);\n\n    for (var i = 1; i < len; i++) {\n      if (!prev[i]) {\n        continue;\n      }\n\n      if (!xref_table[i]) {\n        xref_table[i] = prev[i];\n      }\n    }\n  }\n\n  function inflate(content, params_map) {\n    var columns;\n    var predictor = 1;\n\n    if (params_map) {\n      predictor = params_map.Predictor;\n      columns = params_map.Columns;\n\n      if (params_map.Colors) {\n        if (params_map.Colors != 1) {\n          throw new Error('Unsupported predictor Colors value: ' + params_map.Colors);\n        }\n      }\n\n      if (params_map.BitsPerComponent) {\n        if (params_map.BitsPerComponent != 8) {\n          throw new Error('Unsupported predictor BitsPerComponent value: ' + params_map.BitsPerComponent);\n        }\n      }\n    }\n\n    var res = pako.inflate(content);\n\n    if (predictor == 1) {\n      return res;\n    }\n\n    assert(columns > 0, 'columns must be set for PNG predictors');\n\n    if (predictor >= 10 && predictor <= 15) {\n      res = png_filter(res, columns);\n    } else {\n      throw new Error('Unsupported predictor ' + predictor);\n    }\n\n    return res;\n  }\n\n  function parse(buf) {\n    return new PDFDocument(buf);\n  }\n\n  var PDFDocument = function (buf) {\n    this._cached_object_streams = {};\n    this.buf = buf;\n    this.reader = new PDFReader(buf);\n    check_header(buf);\n    this.startXRef = find_startxref(buf);\n    this.reader.pos = this.startXRef;\n    var xref_res = this.reader.parse_xref();\n    this.xref = xref_res.xref;\n    assert(isArray(this.xref));\n    this.meta = xref_res.meta;\n    assert(this.meta.Root, 'meta.Root missing');\n    assert(isRef(this.meta.Root), 'meta.root should be Ref');\n    this.root = this.fetch(this.meta.Root);\n    this.xref_type = this.reader.xref_type;\n    var af_node = this.get_acroform_ref();\n\n    if (isRef(af_node)) {\n      this.acroForm = this.fetch(af_node);\n    } else {\n      this.acroForm = af_node;\n    }\n  };\n\n  PDFDocument.prototype.get_root_id = function () {\n    return this.meta.Root.num;\n  };\n\n  PDFDocument.prototype.get_xref_entries = function () {\n    return this.xref;\n  };\n\n  PDFDocument.prototype.get_acroform_ref = function () {\n    return this.root.map.AcroForm;\n  };\n\n  PDFDocument.prototype.fetch = function (ref, recursive) {\n    assert(ref instanceof Ref);\n    var xref_entry = this.xref[ref.num];\n\n    if (!xref_entry) {\n      throw new Error('Cannot find object ' + ref.num + ' in xref table');\n    }\n\n    if (xref_entry.type === 0) {\n      throw new Error('Cannot fetch a free object');\n    }\n\n    if (xref_entry.type == 2) {\n      if (recursive) {\n        throw new Error('Cannot fetch object stream inside object stream');\n      }\n\n      if (ref.gen !== 0) {\n        throw new Error('Object with reference ' + ref.gen + ' cannot be found in object stream');\n      }\n\n      var object_stream = this._cached_object_streams[xref_entry.offset];\n\n      if (!object_stream) {\n        var object_stream_obj = this.fetch(new Ref(xref_entry.offset, 0), true);\n        object_stream = parse_object_stream(object_stream_obj);\n        this._cached_object_streams[xref_entry.offset] = object_stream;\n      }\n\n      if (!(ref.num in object_stream)) {\n        throw new Error('Could not find object ' + ref.num + ' in object stream with entries ' + JSON.stringify(Object.keys(object_stream)));\n      }\n\n      var res = object_stream[ref.num];\n      return res;\n    }\n\n    if (ref.gen != xref_entry.gen) {\n      throw new Error('Invalid generation: Asked for ' + ref.gen + ', table has ' + xref_entry.gen);\n    }\n\n    this.reader.pos = xref_entry.offset;\n    var obj = this.reader.parse_object();\n    console.log(obj);\n\n    if (obj.num !== ref.num) {\n      throw new Error('Expected to read object with ID ' + ref.num + ', but found ' + obj.num);\n    }\n\n    if (obj.gen !== ref.gen) {\n      throw new Error('Expected to read object with gen ' + ref.gen + ', but found ' + obj.gen);\n    }\n\n    return obj.obj;\n  };\n\n  var PDFReader = function (buf) {\n    assert(buf instanceof Uint8Array, 'Expected a buffer of type Uint8Array');\n    assert(buf.BYTES_PER_ELEMENT === 1, 'not a Uint8Array!');\n    this.buf = buf;\n    this.pos = 0;\n  };\n\n  PDFReader.prototype = {\n    skip_space: function () {\n      while (this.pos < this.buf.length) {\n        var c = this.buf[this.pos];\n\n        if (c == 9 || c == 10 || c == 13 || c == 32) {\n          this.pos++;\n        } else {\n          break;\n        }\n      }\n    },\n    skip_start: function (str) {\n      if (startswith(this.buf, this.pos, str)) {\n        this.pos += str.length;\n        return true;\n      }\n\n      return false;\n    },\n    read_uint: function (len) {\n      var res = 0;\n\n      while (len > 0) {\n        assert(this.buf[this.pos] !== undefined, 'reading uint at position ' + this.pos + ' of ' + this.buf.length);\n        res = (res << 8 | this.buf[this.pos] & 0xff) >>> 0;\n        this.pos++;\n        len--;\n      }\n\n      return res;\n    },\n    parse_string: function () {\n      var res = '';\n      var parens = 1;\n\n      while (this.pos < this.buf.length) {\n        var c = String.fromCharCode(this.buf[this.pos]);\n        this.pos++;\n\n        if (c == ')') {\n          parens--;\n\n          if (parens === 0) {\n            break;\n          }\n\n          res += c;\n        } else if (c == '(') {\n          parens++;\n          res += c;\n        } else if (c == '\\\\') {\n          c = String.fromCharCode(this.buf[this.pos]);\n          this.pos++;\n\n          switch (c) {\n            case 'n':\n              res += '\\n';\n              break;\n\n            case 'r':\n              res += '\\r';\n              break;\n\n            case 't':\n              res += '\\t';\n              break;\n\n            case '\\r':\n            case '\\n':\n              break;\n\n            case '\\\\':\n            case '(':\n            case ')':\n              res += c;\n              break;\n\n            default:\n              throw new Error('Unsupported escape \"' + c + '\"');\n          }\n        } else {\n          res += c;\n        }\n      }\n\n      return res;\n    },\n    parse_hex_string: function () {\n      var start_pos = this.pos;\n\n      while (this.pos < this.buf.length) {\n        if (this.buf[this.pos] == '>'.charCodeAt(0)) {\n          break;\n        }\n\n        this.pos++;\n      }\n\n      var hex_str = buf2str(this.buf, start_pos, this.pos);\n      this.pos++;\n\n      if (hex_str.length % 2 == 1) {\n        hex_str += '0';\n      }\n\n      if (!/^[0-9A-Fa-f]*$/.test(hex_str)) {\n        throw new Error('Invalid hex string ' + hex_str);\n      }\n\n      return hex_str.replace(/([0-9A-Fa-f]{2})/g, function () {\n        return String.fromCharCode(parseInt(arguments[1], 16));\n      });\n    },\n    parse_num: function () {\n      var res = 0;\n      var first_pos = this.pos;\n\n      while (this.pos < this.buf.length) {\n        var by = this.buf[this.pos];\n\n        if (48 <= by && by <= 57) {\n          res = res * 10 + by - 48;\n        } else {\n          break;\n        }\n\n        this.pos++;\n      }\n\n      if (first_pos === this.pos) {\n        throw new Error('Not an ASCII number byte: ' + this.buf[this.pos]);\n      }\n\n      return res;\n    },\n    parse_name: function () {\n      var start_pos = this.pos;\n      var DELIM_CHARS = [0, 9, 13, 10, 32, 40, 41, 60, 62, 91, 93, 123, 125, 47, 37];\n\n      while (this.pos < this.buf.length) {\n        if (DELIM_CHARS.indexOf(this.buf[this.pos]) >= 0) {\n          break;\n        }\n\n        this.pos++;\n      }\n\n      var name = buf2str(this.buf, start_pos, this.pos);\n      name = name.replace(/#([0-9a-fA-F]{2})/g, function (_, hex) {\n        return String.fromCharCode(parseInt(hex, 16));\n      });\n      return new Name(name);\n    },\n    parse_array: function () {\n      var res = [];\n\n      for (;;) {\n        this.skip_space();\n\n        if (this.buf[this.pos] == 93) {\n          // ]\n          break;\n        }\n\n        var el = this.parse();\n        res.push(el);\n      }\n\n      this.pos++;\n      return res;\n    },\n    parse_dict: function () {\n      var map = {};\n\n      while (this.pos < this.buf.length) {\n        this.skip_space();\n\n        if (this.skip_start('>>')) {\n          break;\n        }\n\n        if (!this.skip_start('/')) {\n          throw new Error('Key is not a name in dict');\n        }\n\n        var k = this.parse_name();\n        var v = this.parse();\n        map[k.name] = v;\n      }\n\n      var sav_pos = this.pos;\n      this.skip_space();\n\n      if (this.skip_start('stream\\r\\n') || this.skip_start('stream\\n') || this.skip_start('stream')) {\n        return this.parse_stream_content(map);\n      } else {\n        this.pos = sav_pos;\n        return new Dict(map);\n      }\n    },\n    parse_stream_content: function (map) {\n      if (typeof map.Length != 'number') {\n        throw new Error('Stream Length field missing or invalid: ' + JSON.stringify(map.Length));\n      }\n\n      if (this.pos + map.Length > this.buf.length) {\n        throw new Error('Stream Length too large');\n      }\n\n      var content = this.buf.subarray(this.pos, this.pos + map.Length);\n      this.pos += map.Length;\n      this.skip_space();\n\n      if (!this.skip_start('endstream')) {\n        throw new Error('Missing endstream');\n      }\n\n      if (map.Filter) {\n        var filters = map.Filter instanceof Array ? map.Filter : [map.Filter];\n        var params = map.DecodeParms instanceof Array ? map.DecodeParms : [map.DecodeParms];\n\n        for (var i = 0; i < filters.length; i++) {\n          var filter_params = params[i];\n\n          switch (filters[i].name) {\n            case 'FlateDecode':\n              content = inflate(content, filter_params ? filter_params.map : filter_params);\n              break;\n\n            default:\n              throw new Error('Unsupported filter: ' + JSON.stringify(filters[i].name));\n          }\n        }\n      }\n\n      return new Stream(map, content);\n    },\n    parse: function () {\n      this.skip_space();\n\n      if (this.skip_start('<<')) {\n        return this.parse_dict();\n      }\n\n      if (this.skip_start('[')) {\n        return this.parse_array();\n      }\n\n      if (this.skip_start('(')) {\n        return this.parse_string();\n      }\n\n      if (this.skip_start('<')) {\n        return this.parse_hex_string();\n      }\n\n      if (this.skip_start('/')) {\n        return this.parse_name();\n      }\n\n      if (this.skip_start('true')) {\n        return true;\n      }\n\n      if (this.skip_start('false')) {\n        return false;\n      }\n\n      if (this.skip_start('null')) {\n        return null;\n      }\n\n      var s = buf2str(this.buf, this.pos, this.pos + 32);\n      var m = /^([0-9]+)\\s+([0-9]+)\\s+R/.exec(s);\n\n      if (m) {\n        this.pos += m[0].length;\n        return new Ref(parseInt(m[1], 10), parseInt(m[2], 10));\n      }\n\n      m = /^[+-]?(?:[0-9]*\\.[0-9]*|[0-9]+)/.exec(s);\n\n      if (m) {\n        this.pos += m[0].length;\n        return parseFloat(m[0]);\n      }\n\n      throw new Error('Unable to parse ' + buf2str(this.buf, this.pos, this.pos + 40));\n    },\n    parse_xref: function () {\n      var i;\n\n      if (startswith(this.buf, this.pos, 'xref')) {\n        // Textual xref table;\n        this.xref_type = 'table';\n        return this.parse_xref_table();\n      }\n\n      this.xref_type = 'stream';\n      var obj = this.parse_object().obj;\n      var xref = [];\n\n      if ('Prev' in obj.map) {\n        var sav_pos = this.pos;\n        this.pos = obj.map.Prev;\n        xref = this.parse_xref().xref;\n        this.pos = sav_pos;\n      }\n\n      assert(obj instanceof Stream, 'XRefs should be a stream, got ' + JSON.stringify(obj) + ' instead');\n      assert(obj.map.Type.name === 'XRef', 'XRef table should be of Type XRef');\n      assert(obj.map.W.length == 3);\n      var type_length = obj.map.W[0];\n      assert(type_length <= 4);\n      var offset_length = obj.map.W[1];\n      assert(offset_length >= 1 && offset_length <= 4);\n      var gen_length = obj.map.W[2];\n      assert(gen_length >= 1 && gen_length <= 4);\n      assert(obj.content.length % (type_length + offset_length + gen_length) === 0, 'content is ' + obj.content.length + ' bytes long, each entry is ' + JSON.stringify(obj.map.W));\n      var total_count = obj.content.length / (type_length + offset_length + gen_length);\n      var index = obj.map.Index;\n\n      if (index) {\n        var aggregate_count = 0;\n\n        for (i = 0; i < index.length; i += 2) {\n          assert(typeof index[i] == 'number');\n          assert(typeof index[i + 1] == 'number');\n          aggregate_count += index[i + 1];\n        }\n\n        assert(aggregate_count == total_count, 'Invalid xref stream index: index says ' + aggregate_count + ' objects, but space for ' + total_count);\n      } else {\n        index = [0, total_count];\n      }\n\n      var reader = new PDFReader(obj.content);\n\n      for (var index_i = 0; index_i < index.length; index_i += 2) {\n        var first_index = index[index_i];\n        var count = index[index_i + 1];\n\n        for (i = 0; i < count; i++) {\n          var type = 1;\n\n          if (type_length) {\n            type = reader.read_uint(type_length);\n          }\n\n          var offset = reader.read_uint(offset_length);\n          var gen = reader.read_uint(gen_length);\n          var xr_dict = {\n            type: type,\n            offset: offset,\n            gen: gen\n          };\n\n          if (type === 0) {\n            xr_dict.free = true;\n          } else {\n            xr_dict.uncompressed = type != 2;\n          }\n\n          xref[first_index + i] = xr_dict;\n        }\n      }\n\n      assert(reader.at_eof());\n      return {\n        meta: obj.map,\n        xref: xref\n      };\n    },\n    parse_object: function () {\n      var s = buf2str(this.buf, this.pos, this.pos + 32);\n      var m = /^([0-9]+)\\s+([0-9]+)\\s+obj/.exec(s);\n\n      if (!m) {\n        throw new Error('Missing object ID: ' + s);\n      }\n\n      var real_num = parseInt(m[1], 10);\n      var real_gen = parseInt(m[2], 10);\n      this.pos += m[0].length;\n      var obj = this.parse();\n      this.skip_space();\n\n      if (!this.skip_start('endobj')) {\n        throw new Error('endobj missing, current str: ' + JSON.stringify(buf2str(this.buf, this.pos, this.pos + 32)));\n      }\n\n      return {\n        obj: obj,\n        num: real_num,\n        gen: real_gen\n      };\n    },\n    parse_xref_table: function () {\n      if (!this.skip_start('xref')) {\n        throw new Error('xref table does not start with xref!');\n      }\n\n      this.skip_space();\n      var start_num = this.parse_num();\n      var xref = [];\n\n      for (var j = 0; j < start_num; j++) {\n        xref.push(undefined);\n      }\n\n      this.skip_space();\n      this.parse_num(); // count. Sometimes this is just a lie though, so ignore it\n\n      for (;;) {\n        this.skip_space();\n\n        if (this.skip_start('trailer')) {\n          break;\n        }\n\n        var offset = this.parse_num();\n        this.skip_space();\n        var gen = this.parse_num();\n        this.skip_space();\n        var usage = this.buf[this.pos];\n\n        if (usage == 102 || usage == 110) {\n          // n and f\n          this.pos++;\n        } else {\n          // no usage character: this means we need to skip\n          while (xref.length < offset) {\n            xref.push(undefined);\n          }\n\n          continue;\n        }\n\n        xref.push({\n          offset: offset,\n          gen: gen,\n          is_free: usage === 102\n        });\n      }\n\n      var meta = this.parse();\n\n      if (meta.map.Prev) {\n        this.pos = meta.map.Prev;\n        var old = this.parse_xref_table();\n\n        _merge_xrefs(xref, old.xref);\n      }\n\n      return {\n        xref: xref,\n        meta: meta.map\n      };\n    },\n    at_eof: function () {\n      return this.pos == this.buf.length;\n    }\n  };\n\n  function startswith(buf, pos, str) {\n    for (var i = 0; i < str.length; i++) {\n      if (str.charCodeAt(i) != buf[pos + i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function buf2str(buf, from, to) {\n    if (from === undefined) {\n      from = 0;\n    }\n\n    if (to === undefined) {\n      to = buf.length;\n    }\n\n    var max = Math.min(to, buf.length);\n    var res = '';\n\n    for (var i = from; i < max; i++) {\n      res += String.fromCharCode(buf[i]);\n    }\n\n    return res;\n  }\n\n  function check_header(buf) {\n    if (!startswith(buf, 0, '%PDF-')) {\n      throw new Error('Does not look like a PDF file!');\n    }\n  }\n\n  function find_startxref(buf) {\n    var s = buf2str(buf, buf.length - 40, buf.length);\n    var m = /startxref\\s*([0-9]+)/.exec(s);\n\n    if (!m) {\n      throw new Error('Cannot find startxref!');\n    }\n\n    return parseInt(m[1]);\n  }\n\n  function parse_object_stream(os_obj) {\n    assert(os_obj.map.Type.name === 'ObjStm', 'Strange Type for an object stream: ' + JSON.stringify(os_obj.map.Type.name));\n    var s = buf2str(os_obj.content, 0, os_obj.map.First);\n    var rex = /\\s*([0-9]+)\\s+([0-9]+)/g;\n    var res = [];\n    var r = new PDFReader(os_obj.content);\n\n    for (var i = 0; i < os_obj.map.N; i++) {\n      var m = rex.exec(s);\n\n      if (!m) {\n        throw new Error('Expected ' + os_obj.map.N + ' objects in this object stream, failed to read number ' + i);\n      }\n\n      var num = parseInt(m[1], 10);\n      var offset = parseInt(m[2], 10);\n      r.pos = offset + os_obj.map.First;\n      res[num] = r.parse();\n    }\n\n    return res;\n  }\n\n  return {\n    parse: parse,\n    PDFDocument: PDFDocument,\n    isName: isName,\n    isStream: isStream,\n    isDict: isDict,\n    isRef: isRef,\n    isNum: isNum,\n    isArray: isArray,\n    isString: isString,\n    isBool: isBool,\n    isNull: isNull,\n    newStream: newStream,\n    assert: assert,\n    buf2str: buf2str,\n    str2buf: str2buf,\n    // Testing only\n    PDFReader: PDFReader,\n    Name: Name,\n    Dict: Dict,\n    Ref: Ref,\n    Stream: Stream\n  };\n}();\n\nif (typeof module != 'undefined' && typeof require != 'undefined') {\n  var pako = require('pako');\n\n  module.exports = minipdf;\n}","map":{"version":3,"sources":["/Users/Shared/Previously Relocated Items/Security/development/react/wizard/node_modules/pdfform.js/minipdf.js"],"names":["minipdf","Name","name","isName","obj","Dict","map","isDict","Stream","content","dict","prototype","getBytes","newStream","assert","Uint8Array","isStream","Ref","num","gen","isRef","isBool","isNull","isString","isNum","isArray","Array","x","msg","Error","str2buf","s","uint","length","i","slen","charCodeAt","png_filter","columns","cols","rows","res","y","filter","prev","_merge_xrefs","xref_table","len","Math","max","inflate","params_map","predictor","Predictor","Columns","Colors","BitsPerComponent","pako","parse","buf","PDFDocument","_cached_object_streams","reader","PDFReader","check_header","startXRef","find_startxref","pos","xref_res","parse_xref","xref","meta","Root","root","fetch","xref_type","af_node","get_acroform_ref","acroForm","get_root_id","get_xref_entries","AcroForm","ref","recursive","xref_entry","type","object_stream","offset","object_stream_obj","parse_object_stream","JSON","stringify","Object","keys","parse_object","console","log","BYTES_PER_ELEMENT","skip_space","c","skip_start","str","startswith","read_uint","undefined","parse_string","parens","String","fromCharCode","parse_hex_string","start_pos","hex_str","buf2str","test","replace","parseInt","arguments","parse_num","first_pos","by","parse_name","DELIM_CHARS","indexOf","_","hex","parse_array","el","push","parse_dict","k","v","sav_pos","parse_stream_content","Length","subarray","Filter","filters","params","DecodeParms","filter_params","m","exec","parseFloat","parse_xref_table","Prev","Type","W","type_length","offset_length","gen_length","total_count","index","Index","aggregate_count","index_i","first_index","count","xr_dict","free","uncompressed","at_eof","real_num","real_gen","start_num","j","usage","is_free","old","from","to","min","os_obj","First","rex","r","N","module","require","exports"],"mappings":"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","sourcesContent":["var minipdf = (function() {\n'use strict';\n\nvar Name = function (name) {\n\tthis.name = name;\n};\nfunction isName(obj) {\n\treturn obj instanceof Name;\n}\nvar Dict = function (map) {\n\tthis.map = map;\n};\nfunction isDict(obj) {\n\treturn obj instanceof Dict;\n}\nvar Stream = function(map, content) {\n\tthis.map = map;\n\tthis.content = content;\n\tthis.dict = new Dict(map);\n};\n// pdf.js compatibility\nStream.prototype.getBytes = function() {\n\treturn this.content;\n};\nfunction newStream(map, content) {\n\tassert(content instanceof Uint8Array, 'stream content must be an Uint8Array');\n\treturn new Stream(map, content);\n}\nfunction isStream(obj) {\n\treturn obj instanceof Stream;\n}\nvar Ref = function(num, gen) {\n\tthis.num = num;\n\tthis.gen = gen;\n};\nfunction isRef(obj) {\n\treturn obj instanceof Ref;\n}\n\nfunction isBool(obj) {\n\treturn typeof obj == 'boolean';\n}\nfunction isNull(obj) {\n\treturn obj === null;\n}\nfunction isString(obj) {\n\treturn typeof obj == 'string';\n}\nfunction isNum(obj) {\n\treturn typeof obj == 'number';\n}\nfunction isArray(obj) {\n\treturn obj instanceof Array;\n}\n\nfunction assert(x, msg) {\n\tif (x) {\n\t\treturn;\n\t}\n\tif (!msg) {\n\t\tmsg = 'Assertion failed';\n\t}\n\tthrow new Error(msg);\n}\n\nfunction str2buf(s) {\n\tvar uint = new Uint8Array(s.length);\n\tfor(var i=0,slen=s.length;i < slen;i++){\n\t\tuint[i] = s.charCodeAt(i);\n\t}\n\treturn uint;\n}\n\nfunction png_filter(content, columns) {\n\tvar cols = columns + 1;\n\tvar rows = content.length / cols;\n\tassert(rows % 1 === 0, 'Invalid column value ' + cols + ' for image width ' + content.length);\n\tvar res = new Uint8Array(columns * rows);\n\tfor (var y = 0;y < rows;y++) {\n\t\tvar x;\n\t\tvar filter = content[y * cols];\n\n\t\tif (filter === 0) {\n\t\t\tfor (x = 0;x < columns;x++) {\n\t\t\t\tres[y * columns + x] = content[y * cols + 1 + x];\n\t\t\t}\n\t\t} else if (filter === 2) {\n\t\t\tfor (x = 0;x < columns;x++) {\n\t\t\t\tvar prev = (y === 0) ? 0 : res[(y - 1) * columns + x];\n\t\t\t\tres[y * columns + x] = (prev + content[y * cols + 1 + x]) & 0xff;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Unsupported PNG filter ' + filter);\n\t\t}\n\t}\n\treturn res;\n}\n\n\nfunction _merge_xrefs(xref_table, prev) {\n\tvar len = Math.max(xref_table.length, prev.length);\n\tfor (var i = 1;i < len;i++) {\n\t\tif (!prev[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!xref_table[i]) {\n\t\t\txref_table[i] = prev[i];\n\t\t}\n\t}\n}\n\n\nfunction inflate(content, params_map) {\n\tvar columns;\n\tvar predictor = 1;\n\tif (params_map) {\n\t\tpredictor = params_map.Predictor;\n\t\tcolumns = params_map.Columns;\n\t\tif (params_map.Colors) {\n\t\t\tif (params_map.Colors != 1) {\n\t\t\t\tthrow new Error('Unsupported predictor Colors value: ' + params_map.Colors);\n\t\t\t}\n\t\t}\n\t\tif (params_map.BitsPerComponent) {\n\t\t\tif (params_map.BitsPerComponent != 8) {\n\t\t\t\tthrow new Error('Unsupported predictor BitsPerComponent value: ' + params_map.BitsPerComponent);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar res = pako.inflate(content);\n\tif (predictor == 1) {\n\t\treturn res;\n\t}\n\n\tassert(columns > 0, 'columns must be set for PNG predictors');\n\n\tif ((predictor >= 10) && (predictor <= 15)) {\n\t\tres = png_filter(res, columns);\n\t} else {\n\t\tthrow new Error('Unsupported predictor ' + predictor);\n\t}\n\treturn res;\n}\n\nfunction parse(buf) {\n\treturn new PDFDocument(buf);\n}\n\nvar PDFDocument = function(buf) {\n\tthis._cached_object_streams = {};\n\n\tthis.buf = buf;\n\tthis.reader = new PDFReader(buf);\n\n\tcheck_header(buf);\n\tthis.startXRef = find_startxref(buf);\n\tthis.reader.pos = this.startXRef;\n\n\tvar xref_res = this.reader.parse_xref();\n\tthis.xref = xref_res.xref;\n\tassert(isArray(this.xref));\n\tthis.meta = xref_res.meta;\n\tassert(this.meta.Root, 'meta.Root missing');\n\tassert(isRef(this.meta.Root), 'meta.root should be Ref');\n\n\tthis.root = this.fetch(this.meta.Root);\n\tthis.xref_type = this.reader.xref_type;\n\n\tvar af_node = this.get_acroform_ref();\n\tif (isRef(af_node)) {\n\t\tthis.acroForm = this.fetch(af_node);\n\t} else {\n\t\tthis.acroForm = af_node;\n\t}\n};\nPDFDocument.prototype.get_root_id = function() {\n\treturn this.meta.Root.num;\n};\nPDFDocument.prototype.get_xref_entries = function() {\n\treturn this.xref;\n};\nPDFDocument.prototype.get_acroform_ref = function() {\n\treturn this.root.map.AcroForm;\n};\nPDFDocument.prototype.fetch = function(ref, recursive) {\n\tassert(ref instanceof Ref);\n\n\tvar xref_entry = this.xref[ref.num];\n\tif (! xref_entry) {\n\t\tthrow new Error('Cannot find object ' + ref.num + ' in xref table');\n\t}\n\tif (xref_entry.type === 0) {\n\t\tthrow new Error('Cannot fetch a free object');\n\t}\n\tif (xref_entry.type == 2) {\n\t\tif (recursive) {\n\t\t\tthrow new Error('Cannot fetch object stream inside object stream');\n\t\t}\n\t\tif (ref.gen !== 0) {\n\t\t\tthrow new Error('Object with reference ' + ref.gen + ' cannot be found in object stream');\n\t\t}\n\t\tvar object_stream = this._cached_object_streams[xref_entry.offset];\n\t\tif (! object_stream) {\n\t\t\tvar object_stream_obj = this.fetch(new Ref(xref_entry.offset, 0), true);\n\t\t\tobject_stream = parse_object_stream(object_stream_obj);\n\t\t\tthis._cached_object_streams[xref_entry.offset] = object_stream;\n\t\t}\n\t\tif (! (ref.num in object_stream)) {\n\t\t\tthrow new Error(\n\t\t\t\t'Could not find object ' + ref.num +\n\t\t\t\t' in object stream with entries ' + JSON.stringify(Object.keys(object_stream)));\n\t\t}\n\t\tvar res = object_stream[ref.num];\n\t\treturn res;\n\t}\n\tif (ref.gen != xref_entry.gen) {\n\t\tthrow new Error('Invalid generation: Asked for ' + ref.gen + ', table has ' + xref_entry.gen);\n\t}\n\tthis.reader.pos = xref_entry.offset;\n\n\tvar obj = this.reader.parse_object();\n\tconsole.log(obj)\n\tif (obj.num !== ref.num) {\n\t\tthrow new Error('Expected to read object with ID ' + ref.num + ', but found ' + obj.num);\n\t}\n\tif (obj.gen !== ref.gen) {\n\t\tthrow new Error('Expected to read object with gen ' + ref.gen + ', but found ' + obj.gen);\n\t}\n\treturn obj.obj;\n};\n\nvar PDFReader = function(buf) {\n\tassert(buf instanceof Uint8Array, 'Expected a buffer of type Uint8Array');\n\tassert(buf.BYTES_PER_ELEMENT === 1, 'not a Uint8Array!');\n\tthis.buf = buf;\n\tthis.pos = 0;\n};\nPDFReader.prototype = {\n\tskip_space: function() {\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tvar c = this.buf[this.pos];\n\t\t\tif ((c == 9) || (c == 10) || (c == 13) || (c == 32)) {\n\t\t\t\tthis.pos++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\tskip_start: function(str) {\n\t\tif (startswith(this.buf, this.pos, str)) {\n\t\t\tthis.pos += str.length;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tread_uint: function(len) {\n\t\tvar res = 0;\n\t\twhile(len > 0) {\n\t\t\tassert(this.buf[this.pos] !== undefined, 'reading uint at position ' + this.pos + ' of ' + this.buf.length);\n\t\t\tres = (res << 8 | (this.buf[this.pos] & 0xff)) >>> 0;\n\t\t\tthis.pos++;\n\t\t\tlen--;\n\t\t}\n\t\treturn res;\n\t},\n\tparse_string: function() {\n\t\tvar res = '';\n\t\tvar parens = 1;\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tvar c = String.fromCharCode(this.buf[this.pos]);\n\t\t\tthis.pos++;\n\t\t\tif (c == ')') {\n\t\t\t\tparens--;\n\t\t\t\tif (parens === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += c;\n\t\t\t} else if (c == '(') {\n\t\t\t\tparens++;\n\t\t\t\tres += c;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\tc = String.fromCharCode(this.buf[this.pos]);\n\t\t\t\tthis.pos++;\n\t\t\t\tswitch(c) {\n\t\t\t\tcase 'n':\n\t\t\t\t\tres += '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tres += '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tres += '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\r':\n\t\t\t\tcase '\\n':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '(':\n\t\t\t\tcase ')':\n\t\t\t\t\tres += c;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unsupported escape \"' + c + '\"');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres += c;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\tparse_hex_string: function() {\n\t\tvar start_pos = this.pos;\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tif (this.buf[this.pos] == '>'.charCodeAt(0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.pos++;\n\t\t}\n\t\tvar hex_str = buf2str(this.buf, start_pos, this.pos);\n\t\tthis.pos++;\n\t\tif ((hex_str.length % 2) == 1) {\n\t\t\thex_str += '0';\n\t\t}\n\t\tif (!/^[0-9A-Fa-f]*$/.test(hex_str)) {\n\t\t\tthrow new Error('Invalid hex string ' + hex_str);\n\t\t}\n\t\treturn hex_str.replace(/([0-9A-Fa-f]{2})/g, function() {\n\t\t\treturn String.fromCharCode(parseInt(arguments[1], 16));\n\t\t});\n\t},\n\tparse_num: function() {\n\t\tvar res = 0;\n\t\tvar first_pos = this.pos;\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tvar by = this.buf[this.pos];\n\t\t\tif ((48 <= by) && (by <= 57)) {\n\t\t\t\tres = res * 10 + by - 48;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.pos++;\n\t\t}\n\t\tif (first_pos === this.pos) {\n\t\t\tthrow new Error('Not an ASCII number byte: ' + this.buf[this.pos]);\n\t\t}\n\t\treturn res;\n\t},\n\tparse_name: function() {\n\t\tvar start_pos = this.pos;\n\t\tvar DELIM_CHARS = [0, 9, 13, 10, 32, 40, 41, 60, 62, 91, 93, 123, 125, 47, 37];\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tif (DELIM_CHARS.indexOf(this.buf[this.pos]) >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.pos++;\n\t\t}\n\t\tvar name = buf2str(this.buf, start_pos, this.pos);\n\t\tname = name.replace(/#([0-9a-fA-F]{2})/g, function(_, hex) {\n\t\t\treturn String.fromCharCode(parseInt(hex, 16));\n\t\t});\n\t\treturn new Name(name);\n\t},\n\tparse_array: function() {\n\t\tvar res = [];\n\t\tfor (;;) {\n\t\t\tthis.skip_space();\n\t\t\tif (this.buf[this.pos] == 93) { // ]\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar el = this.parse();\n\t\t\tres.push(el);\n\t\t}\n\t\tthis.pos++;\n\t\treturn res;\n\t},\n\tparse_dict: function() {\n\t\tvar map = {};\n\t\twhile (this.pos < this.buf.length) {\n\t\t\tthis.skip_space();\n\t\t\tif (this.skip_start('>>')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!this.skip_start('/')) {\n\t\t\t\tthrow new Error('Key is not a name in dict');\n\t\t\t}\n\t\t\tvar k = this.parse_name();\n\t\t\tvar v = this.parse();\n\t\t\tmap[k.name] = v;\n\t\t}\n\t\tvar sav_pos = this.pos;\n\t\tthis.skip_space();\n\t\tif (this.skip_start('stream\\r\\n') || this.skip_start('stream\\n') || this.skip_start('stream')) {\n\t\t\treturn this.parse_stream_content(map);\n\t\t} else {\n\t\t\tthis.pos = sav_pos;\n\t\t\treturn new Dict(map);\n\t\t}\n\t},\n\tparse_stream_content: function(map) {\n\t\tif (typeof map.Length != 'number') {\n\t\t\tthrow new Error('Stream Length field missing or invalid: ' + JSON.stringify(map.Length));\n\t\t}\n\t\tif (this.pos + map.Length > this.buf.length) {\n\t\t\tthrow new Error('Stream Length too large');\n\t\t}\n\t\tvar content = this.buf.subarray(this.pos, this.pos + map.Length);\n\t\tthis.pos += map.Length;\n\t\tthis.skip_space();\n\t\tif (!this.skip_start('endstream')) {\n\t\t\tthrow new Error('Missing endstream');\n\t\t}\n\t\tif (map.Filter) {\n\t\t\tvar filters = (map.Filter instanceof Array) ? map.Filter : [map.Filter];\n\t\t\tvar params = (map.DecodeParms instanceof Array) ? map.DecodeParms : [map.DecodeParms];\n\t\t\tfor (var i = 0;i < filters.length;i++) {\n\t\t\t\tvar filter_params = params[i];\n\n\t\t\t\tswitch (filters[i].name) {\n\t\t\t\tcase 'FlateDecode':\n\t\t\t\t\tcontent = inflate(content, filter_params ? filter_params.map : filter_params);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unsupported filter: ' + JSON.stringify(filters[i].name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Stream(map, content);\n\t},\n\tparse: function() {\n\t\tthis.skip_space();\n\t\tif (this.skip_start('<<')) {\n\t\t\treturn this.parse_dict();\n\t\t}\n\t\tif (this.skip_start('[')) {\n\t\t\treturn this.parse_array();\n\t\t}\n\t\tif (this.skip_start('(')) {\n\t\t\treturn this.parse_string();\n\t\t}\n\t\tif (this.skip_start('<')) {\n\t\t\treturn this.parse_hex_string();\n\t\t}\n\t\tif (this.skip_start('/')) {\n\t\t\treturn this.parse_name();\n\t\t}\n\t\t\n\t\tif (this.skip_start('true')) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.skip_start('false')) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.skip_start('null')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar s = buf2str(this.buf, this.pos, this.pos+32);\n\t\tvar m = /^([0-9]+)\\s+([0-9]+)\\s+R/.exec(s);\n\t\tif (m) {\n\t\t\tthis.pos += m[0].length;\n\t\t\treturn new Ref(parseInt(m[1], 10), parseInt(m[2], 10));\n\t\t}\n\t\tm = /^[+-]?(?:[0-9]*\\.[0-9]*|[0-9]+)/.exec(s);\n\t\tif (m) {\n\t\t\tthis.pos += m[0].length;\n\t\t\treturn parseFloat(m[0]);\n\t\t}\n\n\t\tthrow new Error('Unable to parse ' + buf2str(this.buf, this.pos, this.pos + 40));\n\t},\n\tparse_xref: function() {\n\t\tvar i;\n\t\tif (startswith(this.buf, this.pos, 'xref')) {\n\t\t\t// Textual xref table;\n\t\t\tthis.xref_type = 'table';\n\t\t\treturn this.parse_xref_table();\n\t\t}\n\t\tthis.xref_type = 'stream';\n\t\tvar obj = this.parse_object().obj;\n\t\tvar xref = [];\n\n\t\tif ('Prev' in obj.map) {\n\t\t\tvar sav_pos = this.pos;\n\t\t\tthis.pos = obj.map.Prev;\n\t\t\txref = this.parse_xref().xref;\n\t\t\tthis.pos = sav_pos;\n\t\t}\n\n\t\tassert(\n\t\t\tobj instanceof Stream,\n\t\t\t'XRefs should be a stream, got ' + JSON.stringify(obj) + ' instead');\n\t\tassert(\n\t\t\tobj.map.Type.name === 'XRef',\n\t\t\t'XRef table should be of Type XRef');\n\t\tassert(obj.map.W.length == 3);\n\t\tvar type_length = obj.map.W[0];\n\t\tassert(type_length <= 4);\n\t\tvar offset_length = obj.map.W[1];\n\t\tassert((offset_length >= 1) && (offset_length <= 4));\n\t\tvar gen_length = obj.map.W[2];\n\t\tassert((gen_length >= 1) && (gen_length <= 4));\n\t\tassert(\n\t\t\tobj.content.length % (type_length + offset_length + gen_length) === 0,\n\t\t\t'content is ' + obj.content.length + ' bytes long, each entry is ' + JSON.stringify(obj.map.W));\n\n\t\tvar total_count = obj.content.length / (type_length + offset_length + gen_length);\n\t\tvar index = obj.map.Index;\n\t\tif (index) {\n\t\t\tvar aggregate_count = 0;\n\t\t\tfor (i = 0;i < index.length;i += 2) {\n\t\t\t\tassert(typeof index[i] == 'number');\n\t\t\t\tassert(typeof index[i + 1] == 'number');\n\t\t\t\taggregate_count += index[i + 1];\n\t\t\t}\n\t\t\tassert(\n\t\t\t\taggregate_count == total_count,\n\t\t\t\t'Invalid xref stream index: index says ' + aggregate_count + ' objects, but space for ' + total_count);\n\t\t} else {\n\t\t\tindex = [0, total_count];\n\t\t}\n\n\t\tvar reader = new PDFReader(obj.content);\n\t\tfor (var index_i = 0;index_i < index.length;index_i += 2) {\n\t\t\tvar first_index = index[index_i];\n\t\t\tvar count = index[index_i + 1];\n\n\t\t\tfor (i = 0;i < count;i++) {\n\t\t\t\tvar type = 1;\n\t\t\t\tif (type_length) {\n\t\t\t\t\ttype = reader.read_uint(type_length);\n\t\t\t\t}\n\t\t\t\tvar offset = reader.read_uint(offset_length);\n\t\t\t\tvar gen = reader.read_uint(gen_length);\n\t\t\t\tvar xr_dict = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\toffset: offset,\n\t\t\t\t\tgen: gen,\n\t\t\t\t};\n\t\t\t\tif (type === 0) {\n\t\t\t\t\txr_dict.free = true;\n\t\t\t\t} else {\n\t\t\t\t\txr_dict.uncompressed = type != 2;\n\t\t\t\t}\n\t\t\t\txref[first_index + i] = xr_dict;\n\t\t\t}\n\t\t}\n\t\tassert(reader.at_eof());\n\n\t\treturn {\n\t\t\tmeta: obj.map,\n\t\t\txref: xref,\n\t\t};\n\t},\n\tparse_object: function() {\n\t\tvar s = buf2str(this.buf, this.pos, this.pos+32);\n\t\tvar m = /^([0-9]+)\\s+([0-9]+)\\s+obj/.exec(s);\n\t\tif (!m) {\n\t\t\tthrow new Error('Missing object ID: ' + s);\n\t\t}\n\t\tvar real_num = parseInt(m[1], 10);\n\t\tvar real_gen = parseInt(m[2], 10);\n\t\tthis.pos += m[0].length;\n\t\tvar obj = this.parse();\n\t\tthis.skip_space();\n\t\tif (!this.skip_start('endobj')) {\n\t\t\tthrow new Error('endobj missing, current str: ' + JSON.stringify(buf2str(this.buf, this.pos, this.pos+32)));\n\t\t}\n\t\treturn {\n\t\t\tobj: obj,\n\t\t\tnum: real_num,\n\t\t\tgen: real_gen,\n\t\t};\n\t},\n\tparse_xref_table: function() {\n\t\tif (!this.skip_start('xref')) {\n\t\t\tthrow new Error('xref table does not start with xref!');\n\t\t}\n\t\tthis.skip_space();\n\t\tvar start_num = this.parse_num();\n\t\tvar xref = [];\n\t\tfor (var j = 0;j < start_num;j++) {\n\t\t\txref.push(undefined);\n\t\t}\n\t\tthis.skip_space();\n\t\tthis.parse_num();  // count. Sometimes this is just a lie though, so ignore it\n\t\tfor (;;) {\n\t\t\tthis.skip_space();\n\t\t\tif (this.skip_start('trailer')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar offset = this.parse_num();\n\t\t\tthis.skip_space();\n\t\t\tvar gen = this.parse_num();\n\t\t\tthis.skip_space();\n\t\t\tvar usage = this.buf[this.pos];\n\t\t\tif ((usage == 102) || (usage == 110)) { // n and f\n\t\t\t\tthis.pos++;\n\t\t\t} else {\n\t\t\t\t// no usage character: this means we need to skip\n\t\t\t\twhile (xref.length < offset) {\n\t\t\t\t\txref.push(undefined);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\txref.push({\n\t\t\t\toffset: offset,\n\t\t\t\tgen: gen,\n\t\t\t\tis_free: (usage === 102),\n\t\t\t});\n\t\t}\n\n\t\tvar meta = this.parse();\n\t\tif (meta.map.Prev) {\n\t\t\tthis.pos = meta.map.Prev;\n\t\t\tvar old = this.parse_xref_table();\n\t\t\t_merge_xrefs(xref, old.xref);\n\t\t}\n\n\t\treturn {\n\t\t\txref: xref,\n\t\t\tmeta: meta.map,\n\t\t};\n\t},\n\tat_eof: function() {\n\t\treturn this.pos == this.buf.length;\n\t},\n};\n\nfunction startswith(buf, pos, str) {\n\tfor (var i = 0;i < str.length;i++) {\n\t\tif (str.charCodeAt(i) != buf[pos + i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction buf2str(buf, from, to) {\n\tif (from === undefined) {\n\t\tfrom = 0;\n\t}\n\tif (to === undefined) {\n\t\tto = buf.length;\n\t}\n\tvar max = Math.min(to, buf.length);\n\n\tvar res = '';\n\tfor (var i = from;i < max;i++) {\n\t\tres += String.fromCharCode(buf[i]);\n\t}\n\treturn res;\n}\n\n\nfunction check_header(buf) {\n\tif (! startswith(buf, 0, '%PDF-')) {\n\t\tthrow new Error('Does not look like a PDF file!');\n\t}\n}\n\nfunction find_startxref(buf) {\n\tvar s = buf2str(buf, buf.length - 40,buf.length);\n\tvar m = /startxref\\s*([0-9]+)/.exec(s);\n\tif (!m) {\n\t\tthrow new Error('Cannot find startxref!');\n\t}\n\treturn parseInt(m[1]);\n}\n\nfunction parse_object_stream(os_obj) {\n\tassert(\n\t\tos_obj.map.Type.name === 'ObjStm',\n\t\t'Strange Type for an object stream: ' + JSON.stringify(os_obj.map.Type.name));\n\tvar s = buf2str(os_obj.content, 0, os_obj.map.First);\n\tvar rex = /\\s*([0-9]+)\\s+([0-9]+)/g;\n\tvar res = [];\n\tvar r = new PDFReader(os_obj.content);\n\tfor (var i = 0;i < os_obj.map.N;i++) {\n\t\tvar m = rex.exec(s);\n\t\tif (! m) {\n\t\t\tthrow new Error('Expected ' + os_obj.map.N + ' objects in this object stream, failed to read number ' + i);\n\t\t}\n\t\tvar num = parseInt(m[1], 10);\n\t\tvar offset = parseInt(m[2], 10);\n\t\tr.pos = offset + os_obj.map.First;\n\t\tres[num] = r.parse();\n\t}\n\n\treturn res;\n}\n\nreturn {\n\tparse: parse,\n\tPDFDocument: PDFDocument,\n\tisName: isName,\n\tisStream: isStream,\n\tisDict: isDict,\n\tisRef: isRef,\n\tisNum: isNum,\n\tisArray: isArray,\n\tisString: isString,\n\tisBool: isBool,\n\tisNull: isNull,\n\tnewStream: newStream,\n\tassert: assert,\n\tbuf2str: buf2str,\n\tstr2buf: str2buf,\n\n\t// Testing only\n\tPDFReader: PDFReader,\n\tName: Name,\n\tDict: Dict,\n\tRef: Ref,\n\tStream: Stream,\n};\n\n})();\n\nif ((typeof module != 'undefined') && (typeof require != 'undefined')) {\n\tvar pako = require('pako');\n\tmodule.exports = minipdf;\n}\n"]},"metadata":{},"sourceType":"script"}